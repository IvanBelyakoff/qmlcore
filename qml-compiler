#!/usr/bin/env python

import compiler.grammar
import compiler.js
import argparse
import os, os.path
import hashlib
import cPickle

parser = argparse.ArgumentParser()
parser.add_argument("directory", nargs='+')
parser.add_argument("-o", dest="output", default=".")
parser.add_argument("-w", dest="wait", default=False, action='store_true')
args = parser.parse_args()

if args.wait:
	try:
		import pyinotify
	except:
		print "seems that you don't have pyinotify module installed, you can't use -w without it"

compiler.grammar.source.parseWithTabs()
grammar_source = compiler.grammar.__file__
if grammar_source.endswith("pyc"):
	#fixme: check that path exists
	grammar_source = grammar_source[:-1]
with open(grammar_source, "rb") as f:
	data = f.read()
	grammar_digest = hashlib.sha1(data).hexdigest()

project_dirs = args.directory
output_dir = args.output

def check_file(filename):
	if filename[0] == '.':
		return False
	root, ext = os.path.splitext(filename)
	return ext in set([".qml", ".js"])


def process_file(generator, dirpath, filename):
	root, ext = os.path.splitext(filename)
	if root[0] == '.':
		return

	path = os.path.join(dirpath, filename)
	if ext == ".qml":
		com = ".".join(dirpath.split(os.path.sep) + [root])
		cached_path = os.path.join(".cache", com)
		with open(path) as f:
			data = f.read()
			h = hashlib.sha1(grammar_digest + data).hexdigest()
		try:
			with open(cached_path) as f:
				if f.readline().strip() != h:
					raise Exception("invalid hash")
				tree = cPickle.load(f)
		except:
			print "parsing", path, "...", com
			tree = compiler.grammar.parse(data)
			with open(cached_path, "w") as f:
				f.write(h + "\n")
				cPickle.dump(tree, f)

		assert(len(tree) == 1)
		generator.add_component(com, tree[0], root[0].isupper())
	elif ext == ".js":
		with open(path) as f:
			data = f.read()
		print "including js file...", path
		generator.add_js(path, data)


notifier = None
modified = False

if args.wait:
	from pyinotify import WatchManager
	wm = WatchManager()
	mask = pyinotify.IN_MODIFY | pyinotify.IN_CREATE
	for dir in project_dirs:
		wm.add_watch(dir, mask)

	def process_event(event):
		global modified
		if check_file(event.name):
			modified = True

	notifier = pyinotify.Notifier(wm, process_event)

def process_files(generator, dirs):
	for project_dir in dirs:
		for dirpath, dirnames, filenames in os.walk(project_dir):
			for filename in filenames:
				process_file(generator, dirpath, filename)

def generate():
	generator = compiler.js.generator()

	process_files(generator, project_dirs)
	print "generating sources..."
	namespace = "qml"
	app = "'use strict'\n"
	app += "var " + generator.generate(namespace)
	app += generator.generate_startup()
	with open(os.path.join(output_dir, namespace + ".js"), "wt") as f:
		f.write(app)
	print "done"


while True:
	try:
		generate()
	except Exception as ex:
		if not args.wait:
			raise

		import time, traceback
		traceback.print_exc()
		time.sleep(1)
		continue

	if not args.wait:
		break

	while True:
		if notifier.check_events():
			notifier.read_events()
			notifier.process_events()
			if not modified:
				continue
			else:
				modified = False
				break
